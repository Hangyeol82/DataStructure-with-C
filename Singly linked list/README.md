# Singly Linked List (단일 연결 리스트)

 **C 언어로 구현한 단일 연결 리스트 (Singly Linked List)**  
각 노드가 다음 노드의 주소(`next`)를 저장하는 **연결 기반 선형 자료구조**입니다.  
이 구현에서는 **학번(`id`) 기준 오름차순 정렬**을 유지하면서 삽입되도록 작성했습니다.  

---

## 주요 기능

### 1. `insert(int id, char name[])`
- **역할**: 새로운 노드를 정렬된 위치에 삽입.
- **알고리즘 단계**
  1. 새 노드를 동적 할당 (`malloc`) 후, `id`, `name` 저장.
  2. 리스트가 비어 있으면 `first = new_node`.
  3. 새 노드의 `id`가 첫 번째 노드보다 작으면 맨 앞에 삽입.
  4. 그렇지 않으면 `cur`(현재 노드), `pre`(이전 노드)를 순회하면서 **적절한 위치 탐색**.
  5. 위치를 찾으면 `pre->next = new_node`, `new_node->next = cur`.
  6. 끝까지 탐색 후 삽입 위치가 없으면 맨 뒤에 추가.
- **시간 복잡도**: O(n) (최악의 경우 모든 노드 탐색 필요)
- **예외 처리**: 메모리 할당 실패 시 `exit(1)` 종료.

---

### 2. `delete(int id)`
- **역할**: 특정 `id`를 가진 노드를 삭제.
- **알고리즘 단계**
  1. 리스트가 비어 있으면 `"list is empty!"` 출력.
  2. 첫 노드가 대상이면 `first = first->next`, 그리고 `free(cur)`.
  3. 그렇지 않으면 `pre`, `cur`를 순회하며 대상 탐색.
  4. 대상이 존재하면 `pre->next = cur->next` 후 `free(cur)`.
  5. 존재하지 않으면 `"Target doesn't exist!"` 출력.
- **시간 복잡도**: O(n)
- **주의**: 메모리 누수 방지를 위해 반드시 `free` 호출.

---

### 3. `update(int id, char name[])`
- **역할**: 특정 `id`의 노드 이름을 새 값으로 변경.
- **알고리즘 단계**
  1. 리스트가 비어 있으면 `"list is empty!"` 출력.
  2. 순회하면서 `id` ≥ 대상 위치를 찾음.
  3. 대상이 존재하면 `strcpy(cur->name, name)`.
  4. 존재하지 않으면 `"There is no such node!"`.
- **시간 복잡도**: O(n)

---

### 4. `retrieve(int id)`
- **역할**: 특정 `id`를 가진 노드의 `name` 반환.
- **알고리즘 단계**
  1. 리스트가 비어 있으면 `"list is empty!"`.
  2. 순회하면서 대상 탐색.
  3. 발견 시 `cur->name` 반환.
  4. 없으면 `FAIL` 반환.
- **시간 복잡도**: O(n)

---

### 5. `print_linked_list()`
- **역할**: 리스트의 모든 노드를 순서대로 출력.
- **알고리즘 단계**
  1. 리스트가 비어 있으면 `"list is empty!"` 출력.
  2. `first`부터 끝까지 순회하면서 `(id, name)` 출력.
- **시간 복잡도**: O(n)

---

### 6. `free_list()`
- **역할**: 모든 노드를 순회하며 메모리 해제.
- **알고리즘 단계**
  1. `cur`를 `first`로 두고 반복문 실행.
  2. `pre = cur`, `cur = cur->next`, `free(pre)` 실행.
  3. 마지막에 `first = NULL`.
- **시간 복잡도**: O(n)
- **의의**: 프로그램 종료 시 메모리 누수 방지.

---
