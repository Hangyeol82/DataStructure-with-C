# Binary Search Tree (이진 탐색 트리, 파일 기반)

📌 **C 언어로 구현한 파일 기반 이진 탐색 트리 (Binary Search Tree with File Storage)**  
각 노드를 **이진 파일(`bst.bin`)**에 저장하여, 메모리가 아니라 **디스크 기반으로 동작**합니다.  
삭제 시에는 **Free List**를 활용하여 노드 공간을 재사용합니다.  

이 BST는 학번(`num`)을 기준으로 정렬되며, 기본 기능으로 **삽입, 삭제, 검색, 갱신, DFS, BFS**를 지원합니다.  

---

## 📖 주요 기능

### 1. `initialize_tree()`
- **역할**: 새로운 트리 파일(`bst.bin`)을 초기화.
- **동작**
  - `HeadNode`를 파일 맨 앞에 기록.
  - `root_loc = 1`, `free_loc = -1`로 설정.
- **주의**: 프로그램 시작 시 반드시 1회 호출 필요.  

---

### 2. `insert(int num, char name[])`
- **역할**: 새로운 학생 노드를 BST 규칙에 맞게 삽입.
- **동작**
  1. 루트부터 탐색하여 삽입할 위치 결정.
  2. `num`이 작으면 왼쪽, 크면 오른쪽으로 이동.
  3. 삽입 위치가 비어있으면 새 노드를 파일 끝에 쓰거나, Free List 공간을 재사용.
  4. 중복 `num`은 삽입 불가.
- **파일 I/O**
  - `fseek` + `fread`로 부모 노드 탐색.
  - `fseek` + `fwrite`로 부모 포인터 갱신 및 노드 저장.
- **시간 복잡도**: O(h) (트리 높이)

---

### 3. `retrieve(int num)`
- **역할**: 특정 학번(`num`)을 가진 노드를 탐색 후 출력.
- **동작**
  1. 루트에서 시작해 `num` 비교.
  2. 작으면 왼쪽, 크면 오른쪽으로 이동.
  3. 찾으면 `Id, Name` 출력.
  4. 없으면 `"There is no such node!"`.
- **시간 복잡도**: O(h)

---

### 4. `update(int num, char name[])`
- **역할**: 특정 노드의 이름(`name`)을 갱신.
- **동작**
  1. `retrieve`와 동일하게 노드 탐색.
  2. 찾으면 `strcpy` 후 `fwrite`로 갱신.
- **시간 복잡도**: O(h)

---

### 5. `delete(int num)`
- **역할**: 특정 학번(`num`)을 가진 노드를 삭제.
- **케이스 분류**
  1. **자식 없음** → 부모 포인터 NULL, free list에 추가.
  2. **자식 1개** → 부모 포인터를 자식으로 교체.
  3. **자식 2개** → 오른쪽 서브트리에서 가장 작은 노드 찾아 교체.
- **파일 최적화**
  - 마지막 노드일 경우 → `ftruncate`로 파일 크기 줄임.
  - 중간 노드일 경우 → Free List에 추가하여 재사용 가능.
- **시간 복잡도**: O(h)

---

### 6. `dfs()`
- **역할**: 깊이 우선 탐색 (스택 기반).
- **동작**
  1. 루트 위치를 push.
  2. pop하면서 방문 → 출력.
  3. 오른쪽 먼저 push, 왼쪽 나중에 push → 작은 번호 먼저 방문.
- **시간 복잡도**: O(n)

---

### 7. `bfs()`
- **역할**: 너비 우선 탐색 (큐 기반).
- **동작**
  1. 루트 위치를 enqueue.
  2. dequeue하여 방문 → 출력.
  3. 왼쪽 자식, 오른쪽 자식을 enqueue.
- **시간 복잡도**: O(n)

---

### 8. `print_tree()`
- **역할**: 파일 디버깅용. 저장된 순서대로 노드 출력.

- Free List 위치와 Root 위치도 함께 출력.

---

## ⚡ 구현 특징
- **Free List 관리**: 삭제된 노드 공간 재활용.
- **헤더 노드(HeadNode)**: 루트 위치와 Free List 시작 위치 관리.
- **Stack / Queue 모듈**: `stack_queue.c`에 별도 구현.

---

## ⚙️ 컴파일 방법

이 프로젝트는 **여러 파일**로 구성되어 있으므로 반드시 함께 컴파일해야 합니다:

```bash
gcc binary_search_tree.c stack_queue.c -o bst
